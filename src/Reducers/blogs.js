import { ADD_BLOG, SEARCH_RESULT } from "../Constants/Action-Types";

const initialState = { 
	allBlogs : [
		{id:0, author:"Haris", topic:"React Testing Tutorial: Test Frameworks & Component Tests", tags:["React.js", "Testing", "Framework"], article:'<p>Writing tests is an essential part of software development to ensure a robust application. Tests enable us to automatically verify that our application is working on a certain level. The certain level depends on the quality, quantity (coverage) and type of your tests (unit tests, integration tests, end-to-end tests).</p><p>The following article should&nbsp;guide you through the whole topic of testing React apps. Primarily, you will test React components but also pure business logic. The article showcases different testing libraries for your application whereas you can decide which of these solutions make sense for you. It guides you through the whole testing setup for your React application and how to write the tests. It will use testing tools such as Mocha, Chai, Sinon, Enzyme and Jest.</p><p>If you are coming from a&nbsp;create-react-app&nbsp;application, you can ignore most of the setup sections. The create-react-app application comes with Jest as test runner and assertion library. You can add Sinon and Enzyme manually to it.</p><p>Otherwise, I would recommend to use&nbsp;<a href="https://www.robinwieruch.de/minimal-react-webpack-babel-setup/" target="_blank">this article to set up a minimal React with Webpack application</a>. After your application is up and running by following the referenced guide, you can use this testing tutorial to setup your test environment.</p><p>As mentioned, the article will show you&nbsp;<strong>how to setup different testing libraries in your React application and how to use them</strong>. We will follow mostly the constraints of the&nbsp;<a href="https://www.google.com/search?q=testing+pyramid" target="_blank">testing pyramid</a>. It says that you should write mostly unit tests, followed by several integration tests and only a few end-to-end-tests (E2E tests). However, there exists a second philosophy for React applications, because it uses components and not many functions. The second testing philosophy says that you should write “mostly integration tests and not so many unit tests”. We will come back to this topic later in this testing tutorial.</p><p><strong>What are unit, integration, and end-to-end tests in a nutshell?</strong>&nbsp;Whereas a unit test should be able to test a piece (e.g. component) in isolation, the integration test should make sure that the piece (component) works in its context with other pieces (components). For instance, an integration test could verify that all necessary props are passed through from the tested component to a specific child component. Last but not least, end-to-end tests are testing your application in a browser environment. For instance, there you could simulate a whole&nbsp;<a href="https://www.robinwieruch.de/complete-firebase-authentication-react-tutorial/" target="_blank">sign up process</a>&nbsp;by filling in a email address and a password in a form and submitting these credentials to your backend.</p><p>The following article leaves out visual regression tests in React. However, you can deploy those tests as well as you can find over in this article:&nbsp;<a href="https://www.robinwieruch.de/visual-regression-testing-react-storybook" target="_blank">Visual Regression Tests and React Storybook</a>.</p><p>Another goal of the article is to show you a couple of&nbsp;<strong>common test patterns and testing best practices</strong>which are not too complicated and can be applied throughout your application. It should help you to write your React component tests in an efficient way without having to decide every time on how to write the tests themselves. Therefore, most of your tests should follow a common pattern which you can apply throughout your components. These test pattern become even more interesting when using&nbsp;<a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank">TDD</a>, because you can write your tests first and your components in the second step. After all, this guide should show you a couple of React testing best practices without being too opinionated. Hopefully it will help you to understand the React testing framework landscape, how to setup these testing tools up and how to use them.</p>'},
		{id:1, author:"Ahmed", topic:"Senses", tags:["nocommerce","Html","CSS","ArtificalIntellignce"],  article:"this is aritcle"}
	],
	search : [
		{id:0, author:"Haris", topic:"React Testing Tutorial: Test Frameworks & Component Tests", tags:["React.js", "Testing", "Framework"], article:'<p>Writing tests is an essential part of software development to ensure a robust application. Tests enable us to automatically verify that our application is working on a certain level. The certain level depends on the quality, quantity (coverage) and type of your tests (unit tests, integration tests, end-to-end tests).</p><p>The following article should&nbsp;guide you through the whole topic of testing React apps. Primarily, you will test React components but also pure business logic. The article showcases different testing libraries for your application whereas you can decide which of these solutions make sense for you. It guides you through the whole testing setup for your React application and how to write the tests. It will use testing tools such as Mocha, Chai, Sinon, Enzyme and Jest.</p><p>If you are coming from a&nbsp;create-react-app&nbsp;application, you can ignore most of the setup sections. The create-react-app application comes with Jest as test runner and assertion library. You can add Sinon and Enzyme manually to it.</p><p>Otherwise, I would recommend to use&nbsp;<a href="https://www.robinwieruch.de/minimal-react-webpack-babel-setup/" target="_blank">this article to set up a minimal React with Webpack application</a>. After your application is up and running by following the referenced guide, you can use this testing tutorial to setup your test environment.</p><p>As mentioned, the article will show you&nbsp;<strong>how to setup different testing libraries in your React application and how to use them</strong>. We will follow mostly the constraints of the&nbsp;<a href="https://www.google.com/search?q=testing+pyramid" target="_blank">testing pyramid</a>. It says that you should write mostly unit tests, followed by several integration tests and only a few end-to-end-tests (E2E tests). However, there exists a second philosophy for React applications, because it uses components and not many functions. The second testing philosophy says that you should write “mostly integration tests and not so many unit tests”. We will come back to this topic later in this testing tutorial.</p><p><strong>What are unit, integration, and end-to-end tests in a nutshell?</strong>&nbsp;Whereas a unit test should be able to test a piece (e.g. component) in isolation, the integration test should make sure that the piece (component) works in its context with other pieces (components). For instance, an integration test could verify that all necessary props are passed through from the tested component to a specific child component. Last but not least, end-to-end tests are testing your application in a browser environment. For instance, there you could simulate a whole&nbsp;<a href="https://www.robinwieruch.de/complete-firebase-authentication-react-tutorial/" target="_blank">sign up process</a>&nbsp;by filling in a email address and a password in a form and submitting these credentials to your backend.</p><p>The following article leaves out visual regression tests in React. However, you can deploy those tests as well as you can find over in this article:&nbsp;<a href="https://www.robinwieruch.de/visual-regression-testing-react-storybook" target="_blank">Visual Regression Tests and React Storybook</a>.</p><p>Another goal of the article is to show you a couple of&nbsp;<strong>common test patterns and testing best practices</strong>which are not too complicated and can be applied throughout your application. It should help you to write your React component tests in an efficient way without having to decide every time on how to write the tests themselves. Therefore, most of your tests should follow a common pattern which you can apply throughout your components. These test pattern become even more interesting when using&nbsp;<a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank">TDD</a>, because you can write your tests first and your components in the second step. After all, this guide should show you a couple of React testing best practices without being too opinionated. Hopefully it will help you to understand the React testing framework landscape, how to setup these testing tools up and how to use them.</p>'},
		{id:1, author:"Ahmed", topic:"Senses", tags:["nocommerce","Html","CSS","ArtificalIntellignce"],  article:"this is aritcle"}
	] 
}
const blogs = (state = initialState, action) => {
  switch (action.type) {
    case ADD_BLOG:
       action.payload.id = state.allBlogs.length;
       return Object.assign({},state,{allBlogs:[...state.allBlogs, action.payload]});
    case SEARCH_RESULT:
       return Object.assign({},state,{search:action.payload});
    default:
      return state;
  }
};
export default blogs;